#!/usr/bin/perl

use Data::Dumper;

#DEADBEEF
$VAR1 = {
          'any' => {
                     'instr' => 996,
                     'mnem' => 'any',
                     'opcode' => '000003e4',
                     'size' => 4
                   },
          'backcommit' => {
                            'instr' => 263104,
                            'mnem' => 'backcommit',
                            'opcode' => '000403c0',
                            'param1' => 'address',
                            'size' => 8,
                            'terse' => 1
                          },
          'call' => {
                      'instr' => 263042,
                      'mnem' => 'call',
                      'opcode' => '00040382',
                      'param1' => 'address',
                      'size' => 8,
                      'terse' => 1
                    },
          'catch' => {
                       'instr' => 263059,
                       'mnem' => 'catch',
                       'opcode' => '00040393',
                       'param1' => 'address',
                       'size' => 8,
                       'terse' => 1
                     },
          'char' => {
                      'instr' => 263127,
                      'mnem' => 'char',
                      'opcode' => '000403d7',
                      'param1' => 'char',
                      'size' => 8
                    },
          'closecapture' => {
                              'instr' => 262912,
                              'mnem' => 'closecapture',
                              'opcode' => '00040300',
                              'param1' => 'slot',
                              'size' => 8,
                              'terse' => 1
                            },
          'commit' => {
                        'instr' => 262966,
                        'mnem' => 'commit',
                        'opcode' => '00040336',
                        'param1' => 'address',
                        'size' => 8,
                        'terse' => 1
                      },
          'condjump' => {
                          'instr' => 525089,
                          'mnem' => 'condjump',
                          'opcode' => '00080321',
                          'param1' => 'register',
                          'param2' => 'address',
                          'size' => 12
                        },
          'counter' => {
                         'instr' => 525142,
                         'mnem' => 'counter',
                         'opcode' => '00080356',
                         'param1' => 'register',
                         'param2' => 'value',
                         'size' => 12
                       },
          'end' => {
                     'instr' => 262360,
                     'mnem' => 'end',
                     'opcode' => '000400d8',
                     'param1' => 'code',
                     'size' => 8,
                     'terse' => 1
                   },
          'endreplace' => {
                            'instr' => 921,
                            'mnem' => 'endreplace',
                            'opcode' => '00000399',
                            'size' => 4,
                            'terse' => 1
                          },
          'fail' => {
                      'instr' => 843,
                      'mnem' => 'fail',
                      'opcode' => '0000034b',
                      'size' => 4,
                      'terse' => 1
                    },
          'failtwice' => {
                           'instr' => 912,
                           'mnem' => 'failtwice',
                           'opcode' => '00000390',
                           'size' => 4
                         },
          'jump' => {
                      'instr' => 262963,
                      'mnem' => 'jump',
                      'opcode' => '00040333',
                      'param1' => 'address',
                      'size' => 8,
                      'terse' => 1
                    },
          'maskedchar' => {
                            'instr' => 525157,
                            'mnem' => 'maskedchar',
                            'opcode' => '00080365',
                            'param1' => 'char',
                            'param2' => 'mask',
                            'size' => 12,
                            'terse' => 1
                          },
          'noop' => {
                      'instr' => 0,
                      'mnem' => 'noop',
                      'opcode' => '00000000',
                      'size' => 4
                    },
          'opencapture' => {
                             'instr' => 263068,
                             'mnem' => 'opencapture',
                             'opcode' => '0004039c',
                             'param1' => 'slot',
                             'size' => 8,
                             'terse' => 1
                           },
          'partialcommit' => {
                               'instr' => 263092,
                               'mnem' => 'partialcommit',
                               'opcode' => '000403b4',
                               'param1' => 'address',
                               'size' => 8
                             },
          'quad' => {
                      'instr' => 263038,
                      'mnem' => 'quad',
                      'opcode' => '0004037e',
                      'param1' => 'quad',
                      'size' => 8
                    },
          'range' => {
                       'instr' => 525245,
                       'mnem' => 'range',
                       'opcode' => '000803bd',
                       'param1' => 'from',
                       'param2' => 'until',
                       'size' => 12,
                       'terse' => 1
                     },
          'replace' => {
                         'instr' => 525128,
                         'mnem' => 'replace',
                         'opcode' => '00080348',
                         'param1' => 'slot',
                         'param2' => 'address',
                         'size' => 12,
                         'terse' => 1
                       },
          'ret' => {
                     'instr' => 928,
                     'mnem' => 'ret',
                     'opcode' => '000003a0',
                     'size' => 4,
                     'terse' => 1
                   },
          'set' => {
                     'instr' => 2098122,
                     'mnem' => 'set',
                     'opcode' => '002003ca',
                     'param1' => 'set',
                     'size' => 36,
                     'terse' => 1
                   },
          'skip' => {
                      'instr' => 262960,
                      'mnem' => 'skip',
                      'opcode' => '00040330',
                      'param1' => 'number',
                      'size' => 8
                    },
          'span' => {
                      'instr' => 2098145,
                      'mnem' => 'span',
                      'opcode' => '002003e1',
                      'param1' => 'set',
                      'size' => 36
                    },
          'testany' => {
                         'instr' => 262918,
                         'mnem' => 'testany',
                         'opcode' => '00040306',
                         'param1' => 'address',
                         'size' => 8
                       },
          'testchar' => {
                          'instr' => 525210,
                          'mnem' => 'testchar',
                          'opcode' => '0008039a',
                          'param1' => 'address',
                          'param2' => 'char',
                          'size' => 12
                        },
          'testquad' => {
                          'instr' => 525275,
                          'mnem' => 'testquad',
                          'opcode' => '000803db',
                          'param1' => 'address',
                          'param2' => 'quad',
                          'size' => 12
                        },
          'testset' => {
                         'instr' => 2360163,
                         'mnem' => 'testset',
                         'opcode' => '00240363',
                         'param1' => 'address',
                         'param2' => 'set',
                         'size' => 40
                       },
          'trap' => {
                      'instr' => 4278255615,
                      'mnem' => 'trap',
                      'opcode' => 'ff00ffff',
                      'size' => 4
                    },
          'var' => {
                     'instr' => 263150,
                     'mnem' => 'var',
                     'opcode' => '000403ee',
                     'param1' => 'slot',
                     'size' => 8,
                     'terse' => 1
                   }
        };


#/DEADBEEF

my $instructions = $VAR1;
my %labelmap;
my ($inputfile, $outputfile) = ( '-', '-' );
my ($in, $out);

sub do_assemble { return assemble(@_); }
if (caller) { return 1; }

print STDERR "This is Naigama assembler Generation 0.\n";

while (my $arg = shift @ARGV) {
  if ($arg =~ s/^-//) {
    while ($arg =~ s/^(.)//) {
      my $option = $1;
      if ($option eq 'i') {
        $inputfile = shift @ARGV;
      } elsif ($option eq 'o') {
        $outputfile = shift @ARGV;
      } elsif ($option eq 'l') {
        $path = shift @ARGV;
        open $labelmapfile, '>', $path
          || die "Could not open labelmap file $path";
      } elsif ($option eq 'I') {
        my $file = shift @ARGV;
        $instructions = eval(`cat $file`);
      } else {
        die "Unknown command line option '-$option'";
      }
    }
  } else {
    $inputfile = $arg || '-';
    $outputfile = shift @ARGV || '-';
    last;
  }
}

if (!defined($instructions)) {
  die "Need instructions file";
}
if (!scalar(keys(%{$instructions}))) {
  die "No instructions";
} else {
  print STDERR scalar(keys(%{$instructions}))." instructions loaded.\n";
}

if ($inputfile eq '-') {
  $in = *STDIN;
} else {
  open $in, '<', $inputfile || die "Could not open $inputfile";
}

if ($outputfile eq '-') {
  $out = *STDOUT;
} else {
  open $out, '>', $outputfile || die "Could not open $outputfile";
}

my $input = '';
{
  while (my $line = <$in>) {
    $input .= $line;
  }
  close $in;
}

my $bytecode = assemble($input);
print STDERR length($bytecode) . " bytes of bytecode generated.\n";
syswrite $out, $bytecode;
close $out;

if ($labelmapfile) {
  labelmap_write();
}

exit 0;

##---- functions --------------------------------------------------##

sub assemble
{
  my $assembly = shift;
  my @input = split(/\n/, $assembly);
  #print STDERR scalar(@input) . " lines of input assembly.\n";
  
  zeroth_pass(\@input);
  first_pass(\@input);
  my $bytecode = second_pass(\@input);
  return $bytecode;
}

sub zeroth_pass
{
  my $lines = shift;
  foreach my $line (@{$lines}) {
    $line =~ s/--.*$//;
    $line =~ s/\s+$//;
    $line =~ s/^\s+//;
  }
}

sub first_pass
{
  my $lines = shift;
  my $address = 0;
  foreach my $line (@{$lines}) {
    next if (!length($line));
    if ($line =~ /^([a-zA-Z0-9_]+):/) {
      $labelmap{$1} = $address;
    } elsif ($line =~ /^([a-z]+)/) {
      my $opcode = $1;
      if (!defined($instructions->{$opcode})) {
        die "Unknown opcode $line";
      }
      my $size = $instructions->{$opcode}{size};
      $address += $size;
    } else {
      die "Unknown opcode $line";
    }
  }
}

sub enc32bit
{
  my $value = shift;
  my $byte1 = ($value >> 16) & 0xff;
  my $byte2 = ($value >> 8) & 0xff;
  my $byte3 = $value & 0xff;
#  my $byte0 = $byte1 ^ $byte2 ^ $byte3;
  my $byte0 = ($value >> 24) & 0xff;
  return chr($byte0) . chr($byte1) . chr($byte2) . chr($byte3);
}

sub second_pass
{
  my $lines = shift;
  my $address = 0;
  my $char = "[a-f0-9A-F]{2}";
  my $quad = "[a-f0-9A-F]{8}";
  my $label = "[a-zA-Z0-9_]+";
  my $output = '';
  foreach my $line (@{$lines}) {
    my $pos = length($output);
    if ($line =~ /^($label):$/) {
      if ($labelmap{$1} ne $pos) {
        die "Expected to have label at $labelmap{$1} (am at $pos).\n";
      }

    } elsif ($line =~ /^\s*any$/) {
      $output .= enc32bit($instructions->{lc('ANY')}{instr});

    } elsif ($line =~ /^\s*skip\s+([0-9]+)$/) {
      my $n = $1;
      die "Non sensical skip\n" if ($n < 1);
      $output .= enc32bit($instructions->{lc('SKIP')}{instr});
      $output .= enc32bit($n);

    } elsif ($line =~ /^\s*testany\s+($label)$/) {
      $labelmap{'__NEXT__'} = $pos + $instructions->{testany}{size};
      my $address = $labelmap{$1};
      die "Unknown label $1" if (!defined($address));
      $output .= enc32bit($instructions->{lc('TESTANY')}{instr});
      $output .= enc32bit($address);

    } elsif ($line =~ /^\s*char\s+($char)$/) {
      my $c = hex($1);
      $output .= enc32bit($instructions->{lc('CHAR')}{instr});
      $output .= enc32bit($c);

    } elsif ($line =~ /^\s*testchar\s+($char)\s+($label)$/) {
      $labelmap{'__NEXT__'} = $pos + $instructions->{testchar}{size};
      my ($c, $address) = (hex($1), $labelmap{$2});
      die "Unknown label $2" if (!defined($address));
      $output .= enc32bit($instructions->{lc('TESTCHAR')}{instr});
      $output .= enc32bit($address);
      $output .= enc32bit($c);

    } elsif ($line =~ /^\s*quad\s+($quad)$/) {
      my $q = hex($1);
      $output .= enc32bit($instructions->{lc('QUAD')}{instr});
      $output .= pack('N', $q);

    } elsif ($line =~ /^\s*testquad\s+($quad)\s+($label)$/) {
      $labelmap{'__NEXT__'} = $pos + $instructions->{testquad}{size};
      my ($q, $address) = (hex($1), $labelmap{$2});
      die "Unknown label $2" if (!defined($address));
      $output .= enc32bit($instructions->{lc('TESTQUAD')}{instr});
      $output .= enc32bit($address);
      $output .= enc32bit($q);

    } elsif ($line =~ /^\s*set\s+([a-fA-F0-9]{64})$/) {
      my $s = $1;
      $output .= enc32bit($instructions->{lc('SET')}{instr});
      while (length($s)) {
        $s =~ s/^(.{8})//;
        my $h = hex($1);
        $output .= pack('N', $h);
      }

    } elsif ($line =~ /^\s*testset\s+([a-fA-F0-9]{64})\s+($label)$/) {
      $labelmap{'__NEXT__'} = $pos + $instructions->{testset}{size};
      my $s = $1;
      my $address = $labelmap{$2};
      die "Unknown label $2" if (!defined($address));
      $output .= enc32bit($instructions->{lc('TESTSET')}{instr});
      $output .= enc32bit($address);
      while (length($s)) {
        $s =~ s/^(.{8})//;
        my $h = hex($1);
        $output .= pack('N', $h);
      }

    } elsif ($line =~ /^\s*span\s+/) {
      die "Implement";

    } elsif ($line =~ /^\s*catch\s+($label)$/) {
      $labelmap{'__NEXT__'} = $pos + $instructions->{catch}{size};
      my $address = $labelmap{$1};
      die "Unknown label $1" if (!defined($address));
      $output .= enc32bit($instructions->{lc('CATCH')}{instr});
      $output .= enc32bit($address);

    } elsif ($line =~ /^\s*commit\s+($label)$/) {
      $labelmap{'__NEXT__'} = $pos + $instructions->{commit}{size};
      my $address = $labelmap{$1};
      die "Unknown label $1" if (!defined($address));
      $output .= enc32bit($instructions->{lc('COMMIT')}{instr});
      $output .= enc32bit($address);

    } elsif ($line =~ /^\s*partialcommit\s+($label)$/) {
      $labelmap{'__NEXT__'} = $pos + $instructions->{partialcommit}{size};
      my $address = $labelmap{$1};
      die "Unknown label $1" if (!defined($address));
      $output .= enc32bit($instructions->{lc('PARTIALCOMMIT')}{instr});
      $output .= enc32bit($address);

    } elsif ($line =~ /^\s*backcommit\s+($label)$/) {
      $labelmap{'__NEXT__'} = $pos + $instructions->{backcommit}{size};
      my $address = $labelmap{$1};
      die "Unknown label $1" if (!defined($address));
      $output .= enc32bit($instructions->{lc('BACKCOMMIT')}{instr});
      $output .= enc32bit($address);

    } elsif ($line =~ /^\s*fail$/) {
      $output .= enc32bit($instructions->{lc('FAIL')}{instr});

    } elsif ($line =~ /^\s*failtwice$/) {
      $output .= enc32bit($instructions->{lc('FAILTWICE')}{instr});

    } elsif ($line =~ /^\s*jump\s+($label)/) {
      my $address = $labelmap{$1};
      die "Unknown label $1" if (!defined($address));
      $output .= enc32bit($instructions->{lc('JUMP')}{instr});
      $output .= enc32bit($address);

    } elsif ($line =~ /^\s*call\s+($label)/) {
      my $address = $labelmap{$1};
      die "Unknown label $1" if (!defined($address));
      $output .= enc32bit($instructions->{lc('CALL')}{instr});
      $output .= enc32bit($address);

    } elsif ($line =~ /^\s*ret$/) {
      $output .= enc32bit($instructions->{lc('RET')}{instr});

    } elsif ($line =~ /^\s*end$/) {
      $output .= enc32bit($instructions->{lc('END')}{instr});
      $output .= enc32bit(0);

    } elsif ($line =~ /^\s*end\s+([0-9]+)$/) {
      $output .= enc32bit($instructions->{lc('END')}{instr});
      $output .= enc32bit($1);

    } elsif ($line =~ /^\s*opencapture\s+([0-9]+)$/) {
      $output .= enc32bit($instructions->{lc('OPENCAPTURE')}{instr});
      $output .= enc32bit($1);

    } elsif ($line =~ /^\s*closecapture\s+([0-9]+)$/) {
      $output .= enc32bit($instructions->{lc('CLOSECAPTURE')}{instr});
      $output .= enc32bit($1);

    } elsif ($line =~ /^\s*var\s+([0-9]+)$/) {
      $output .= enc32bit($instructions->{lc('VAR')}{instr});
      $output .= enc32bit($1);

    } elsif ($line =~ /^\s*counter\s+([0-9]+)\s+([0-9]+)$/) {
      $output .= enc32bit($instructions->{lc('COUNTER')}{instr});
      $output .= enc32bit($1);
      $output .= enc32bit($2);

    } elsif ($line =~ /^\s*condjump\s+([0-9]+)\s+($label)$/) {
      $labelmap{'__NEXT__'} = $pos + $instructions->{condjump}{size};
      my $address = $labelmap{$2};
      die "Unknown label $2" if (!defined($address));
      $output .= enc32bit($instructions->{lc('CONDJUMP')}{instr});
      $output .= enc32bit($1);
      $output .= enc32bit($address);

    } elsif (length($line)) {
      die "Unknown instruction at $line";
    }
  }
  return $output;
}

sub labelmap_write
{
  foreach my $key (sort(keys(%labelmap))) {
    my $offset = $labelmap{$key};
    syswrite $labelmapfile, enc32bit($offset);
    syswrite $labelmapfile, $key;
    syswrite $labelmapfile, chr(0);
  }
}

1;
